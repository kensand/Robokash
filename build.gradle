plugins {
    id 'java'
    id 'org.jetbrains.kotlin.jvm' version '1.4.10'
    id 'jacoco'
}

apply plugin : "java"

repositories {
    mavenCentral()
    jcenter()
}

compileJava {
    sourceCompatibility = '11'
    targetCompatibility = '11'
}

def CDK_VERSION = "1.92.0"
def JACKSON_VERSION = "2.11.3"
def JUNIT_VERSION = "5.3.1"
def KOTEST_VERSION = "4.3.1"
def KOTLIN_VERSION = "1.4.10"

dependencies {
    implementation 'me.xdrop:fuzzywuzzy:1.3.1'
    implementation 'org.xerial:sqlite-jdbc:3.34.0'
    implementation 'com.xenomachina:kotlin-argparser:2.0.7'

    implementation 'com.amazonaws:aws-lambda-java-core:1.2.0'
    implementation 'com.amazonaws:aws-lambda-java-events:3.1.0'
    implementation 'io.github.microutils:kotlin-logging-jvm:2.0.5'
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$KOTLIN_VERSION"
    implementation "org.jetbrains.kotlin:kotlin-reflect:$KOTLIN_VERSION"

    implementation "com.fasterxml.jackson.core:jackson-core:$JACKSON_VERSION"
    implementation "com.fasterxml.jackson.core:jackson-databind:$JACKSON_VERSION"
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$JACKSON_VERSION"
    implementation "com.fasterxml.jackson.module:jackson-module-kotlin:$JACKSON_VERSION"

    implementation "software.amazon.awscdk:core:$CDK_VERSION"
    implementation "software.amazon.awscdk:lambda:$CDK_VERSION"
    implementation "software.amazon.awscdk:apigatewayv2:$CDK_VERSION"
    implementation "software.amazon.awscdk:apigatewayv2-integrations:$CDK_VERSION"

    // Using Logback because Log4j2 takes like 5 seconds to initialize which sucks for lambda cold starts.
    runtimeOnly "ch.qos.logback:logback-classic:1.2.3"

    testImplementation "org.junit.jupiter:junit-jupiter-api:$JUNIT_VERSION"
    testImplementation "io.kotest:kotest-runner-junit5:$KOTEST_VERSION"
    testImplementation "io.kotest:kotest-assertions-core:$KOTEST_VERSION"
    testImplementation 'io.mockk:mockk:1.10.6'

    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$JUNIT_VERSION"
}

compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

test {
    useJUnitPlatform()
    finalizedBy "jacocoTestReport"
}

jacocoTestReport {
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: 'com/github/goodwillparking/robokash/infra/**')
        }))
    }
}

wrapper {
    distributionType = Wrapper.DistributionType.ALL
}

jar {
    from {
        [
            configurations.runtimeClasspath
                // Quick and dirty way to keep CDK out of the lambda uber-jar.
                // A better solution would be to have a sub-project for CDK.
                .filter { !it.path.contains("software.amazon.awscdk") }
                .collect { it.isDirectory() ? it : zipTree(it) },
            "$project.buildDir/responses.json",
            "$project.buildDir/db.sqlite"
        ]
    }

    dependsOn 'test', 'compileResponsesJson', 'compileResponsesSQLite'
}

// TODO: Don't synth again if sources didn't change.
task cdk(type: JavaExec) {
    main = "com.github.goodwillparking.robokash.infra.AppKt"
    classpath = sourceSets.main.runtimeClasspath
    dependsOn(test, jar) // Jar must exist for cdk deploy
}

// TODO: Don't compile responses if the source file didn't change.
task compileResponsesJson(type: JavaExec) {
    main = "com.github.goodwillparking.robokash.tools.ResponseExtractorJsonKt"
    classpath = sourceSets.test.runtimeClasspath
    args = [project.buildDir.path]
}

// TODO: Don't compile responses if the source file didn't change.
task compileResponsesSQLite(type: JavaExec) {
    main = "com.github.goodwillparking.robokash.tools.ResponseExtractorSQLiteKt"
    classpath = sourceSets.test.runtimeClasspath
    args = []
}

task saveDb()

defaultTasks 'build'
